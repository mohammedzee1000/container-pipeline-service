#!/usr/bin/env python

import json
import logging
import os

from container_pipeline.lib.log import load_logger
from container_pipeline.lib.openshift import Openshift, OpenshiftError
from container_pipeline.workers.base import BaseWorker
from container_pipeline.utils import get_job_name, get_project_name, \
    get_job_hash


class DeliveryWorker(BaseWorker):
    """
    Delivery Worker tags the image built by Build Worker using the
    `desired-tag` field in index entry
    """
    def __init__(self, logger=None, sub=None, pub=None):
        super(DeliveryWorker, self).__init__(logger, sub, pub)
        self.openshift = Openshift(logger=self.logger)

    def handle_job(self, job):
        """Handles a job meant for delivery worker"""
        # TODO: this needs to be addressed after addressing CentOS#278
        self.logger.info('Starting delivery for job: {}'.format(job))

        success = self.deliver_build(job)

        if success:
            self.handle_delivery_success(job)
        else:
            self.handle_delivery_failure(job)

    def deliver_build(self, job):
        """
        Runs an `oc build` with the `run_delivery.sh` script as a part of build
        template. It mainly changes the tag of the image from a test tag
        generated by build process to the tag desired by user as mentioned in
        `desired-tag` field in cccp.yml
        """
        namespace = get_job_name(job)
        project = get_job_hash(namespace)

        try:
            self.openshift.login()
            # start the 'delivery' build
            delivery_id = self.openshift.build(project, 'delivery')
        except OpenshiftError as e:
            logger.error(e)
            return False
        else:
            if not delivery_id:
                return False
        finally:
            self.openshift.delete_pods(project, delivery_id)

        delivery_status = self.openshift.wait_for_build_status(
            project, delivery_id, 'Complete')
        logs = self.openshift.get_build_logs(project, delivery_id)
        delivery_logs_file = os.path.join(job['logs_dir'], 'delivery_logs.txt')
        self.export_build_logs(logs, delivery_logs_file)
        return delivery_status

    def handle_delivery_success(self, job):
        """
        Sends job details to RPM tracking piece and deletes the job from the
        tube
        """
        self.logger.info('Putting job details to master-tube for tracker\'s'
                         ' consumption')
        job['action'] = 'tracking'
        self.queue.put(json.dumps(job), 'master-tube')
        job.delete()

    def handle_delivery_failure(self, job):
        """
        Puts the job back to the delivery tube for later attempt at delivery
        and requests to notify the user about failure to deliver
        """
        self.queue.put(json.dumps(job))
        self.logger.info(
            "Delivery is not successful putting it to failed delivery tube")
        data = {
            'action': 'notify_user',
            'namespace': get_job_name(job),
            'build_status': False,
            'notify_email': job['notify_email'],
            'delivery_logs_file': os.path.join(
                job['logs_dir'], 'delivery_logs.txt'),
            'project_name': get_project_name(job),
            'job_name': job['jobid'],
            'TEST_TAG': job['TEST_TAG']}
        self.logger.debug('Notify delivery failure: {}'.format(data))
        self.notify(data)


if __name__ == "__main__":
    load_logger()
    logger = logging.getLogger('delivery-worker')
    worker = DeliveryWorker(logger, sub='start_delivery',
                            pub='delivery_failed')
    worker.run()
